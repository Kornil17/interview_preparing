# Реализуйте функцию valid_nums_in_segments(), которая принимает два аргумента в следующем порядке:
# nums – список целых чисел
# segments – список кортежей, каждый из которых состоит из двух целых чисел
# Функция должна на отрезках списка nums, перечисленных в списке segments, находить все элементы, которые больше своего левого соседа. Например, если список segments имеет вид [(1; 3), (7; 8)], то функция должна выполнять поиск подходящих значений среди следующих элементов:
# Полученные результаты функция должна вернуть в виде списка, первым элементом которого является количество элементов, которые больше своего левого соседа, на первом отрезке списка nums, вторым – на втором, третьим – на третьем и так далее.
# Примечание. Гарантируется, что в каждом кортеже из списка segments первый элемент не больше второго.


def valid_nums_in_segments(nums: list[int], segments: list[tuple[int, int]]) -> list[int]:
    n = len(nums)
    prefix = [0] * (n + 1)
    for i in range(1, n + 1):
        if i < n and nums[i - 1] < nums[i]:
            prefix[i] = prefix[i - 1] + 1
        else:
            prefix[i] = prefix[i - 1]

    result = []
    for start, stop in segments:
        result.append(prefix[stop] - prefix[start])

    return result

print(valid_nums_in_segments([4, 8, 9, 5, 4, 3, 2, 5], [(0, 3), (2, 5), (5, 7)]))  # (8 > 4, 9 > 8);
                                                                                   # (); (5 > 2)
print(valid_nums_in_segments([1, 2, 3, 4, 5], [(1, 4)]))                           # (3 > 2, 4 > 3,
                                                                                   #  5 > 4)
print(valid_nums_in_segments([5], [(0, 0)]))
print(valid_nums_in_segments([-1, 0, 2, -3, -2], [(0, 1), (1, 3), (2, 4)]))        # (0 > -1); (2 > 0);
                                                                                   # (-2 > -3)
print(valid_nums_in_segments([5, 4, 3, 2, 1], [(0, 1), (1, 3), (2, 4)]))
print(valid_nums_in_segments([1, 2, 3, 4, 5], [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]))
