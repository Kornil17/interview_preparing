Сортировка подсчетом – это алгоритм сортировки набора данных по неубыванию или по невозрастанию.
В отличие от алгоритмов, основанных на сравнении, алгоритм сортировки подсчетом не подходит для сортировки совершенно любых данных.
Основным его назначением является сортировка неотрицательных целых чисел, находящихся в небольшом диапазоне: например, от 0 до 100.
Принцип работы алгоритма сортировки подсчетом можно разделить на два этапа.
На первом этапе алгоритм определяет, сколько раз каждый элемент сортируемого набора встречается в нем.
Для этого алгоритм использует вспомогательный список, изначально заполненный нулями:
Классическая реализация сортировки подсчетом – это алгоритм, который выполняет сортировку списка неотрицательных целых чисел по неубыванию путем его изменения.

Таким образом, алгоритм сортировки подсчетом имеет следующие показатели сложности:

    Временная сложность: O(n+m), где n – длина набора данных, а m – величина его максимального элемента
    Пространственная сложность: O(m), где m – величина максимального элемента набора данных


Преимущества сортировки подсчетом:

    Простота.
        Алгоритм сортировки подсчетом прост для понимания и реализации, что делает его хорошим выбором для обучения основам сортировки
    Высокая производительность.
        Алгоритм сортировки подсчетом имеет временную сложность O(n+m), где n – длина набора данных, а m – величина его максимального элемента. В случаях, когда m<n, временная сложность алгоритма и вовсе становится линейной – O(n).
        Благодаря этому алгоритм подходит для сортировки даже очень больших наборов данных, содержащих около 10^6 элементов, при условии, что значения элементов набора находятся в небольшом диапазоне


Недостатки сортировки подсчетом:

    Ограниченное применение.
        Алгоритм сортировки подсчетом не подходит для сортировки совершенно любых данных. Основным его назначением является сортировка неотрицательных целых чисел, находящихся в небольшом диапазоне
    Сортировка не на месте.
        Алгоритм сортировки подсчетом выполняет сортировку не на месте.
        Он использует вспомогательный список длиной m+1, где m – максимальный элемент сортируемого набора.
        В случаях, когда значение m достаточно велико, алгоритм будет потреблять довольно много дополнительной памяти
    Неестественность поведения.
        Алгоритм сортировки подсчетом ведет себя неестественно.
        Он не учитывает, что набор данных может быть частично или полностью отсортирован, и всегда выполняет одинаковое количество операций, независимо от начального состояния набора данных

----
def counting_sort(data):                # data – непустой список неотрицательных целых чисел
    max_value = max(data)               # определяем максимальный элемент сортируемого списка
    counts = [0] * (max_value + 1)      # создаем вспомогательный список счетчиков

    for elem in data:                   # перебираем все элементы сортируемого списка и отмечаем
        counts[elem] += 1               # во вспомогательном списке, сколько раз встретился каждый из них

    index = 0

    for num in range(max_value + 1):    # перебираем все числа, которые могли встретиться в сортируемом списке
        for _ in range(counts[num]):    # если число встречалось в сортируемом списке (counts[num] > 0),
            data[index] = num           # то помещаем его обратно в сортируемый список в нужном количестве
            index += 1
---
def counting_sort(data):                           # data – непустой список целых чисел
    min_value, max_value = min(data), max(data)    # определяем границы диапазона чисел
    counts = {}                                    # создаем вспомогательный словарь счетчиков

    for elem in data:
        counts[elem] = counts.get(elem, 0) + 1

    index = 0

    for num in range(min_value, max_value + 1):
        for _ in range(counts.get(num, 0)):
            data[index] = num
            index += 1
---
from collections import defaultdict

def counting_sort(data):
    min_value, max_value = min(data), max(data)
    counts = defaultdict(int)

    for elem in data:
        counts[elem] = counts[elem] + 1            # удобное обращение к элементам вспомогательного словаря

    index = 0

    for num in range(min_value, max_value + 1):
        for _ in range(counts[num]):               # удобное обращение к элементам вспомогательного словаря
            data[index] = num
            index += 1
---
from collections import Counter

def counting_sort(data):
    min_value, max_value = min(data), max(data)
    counts = Counter(data)                         # быстрое создание и заполнение вспомогательного словаря

    index = 0

    for num in range(min_value, max_value + 1):
        for _ in range(counts.get(num, 0)):
            data[index] = num
            index += 1
---
