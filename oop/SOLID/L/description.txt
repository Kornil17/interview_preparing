Liskov Substitution Principle - принцип подстановки Лисков

Подклассы должны дополнять, а не замещать поведение базового класса.

Стремитесь создавать подклассы таким образом, чтобы их объекты можно было бы подставлять вместо объектов базового класса, не ломая при этом функциональности клиентского кода.

Принцип подстановки — это ряд проверок, которые помогают предсказать, останется ли подкласс совместим с остальным кодом программы, который до этого успешно работал, используя объекты базового класса.
Это особенно важно при разработке библиотек и фреймворков, когда ваши классы используются другими людьми, и вы не можете повлиять на чужой клиентский код, даже если бы хотели.

В отличие от других принципов, которые определены очень свободно и имеют массу трактовок, принцип подстановки имеет ряд формальных требований к подклассам, а точнее, к переопределённым в них методам.


Типы параметров метода подкласса должны совпадать или быть более абстрактными, чем типы параметров базового метода.
Рассмотрим, как это работает на примере:

    ◦ Базовый класс содержит метод feed(Cat c) , который
    умеет кормить домашних котов. Клиентский код это знает
    и всегда передаёт в метод кота.

    ◦ Хорошо:
        Вы создали подкласс и переопределили метод
        кормёжки так, чтобы накормить любое животное:
        feed(Animal c) . Если подставить этот подкласс в клиент-
        ский код, то ничего страшного не произойдёт. Клиентский
        код подаст в метод кота, но метод умеет кормить всех
        животных, поэтому накормит и кота.

    ◦ Плохо:
        Вы создали другой подкласс, в котором метод
        умеет кормить только бенгальскую породу котов (под-
        класс котов): feed(BengalCat c) . Что будет с клиентским
        кодом? Он всё так же подаст в метод обычного кота. Но
        метод умеет кормить только бенгалов, поэтому не сможет
        отработать, сломав клиентский код.


Тип возвращаемого значения метода подкласса должен совпадать или быть подтипом возвращаемого значения базового метода.
Здесь всё то же, что и в предыдущем пункте, но наоборот. Рассмотрим, как это работает на примере:

    ◦ Базовый метод: buyCat(): Cat . Клиентский код ожидает на выходе любого домашнего кота.

    ◦ Хорошо: Метод подкласса:
        buyCat(): BengalCat . Клиентский код получит бенгальского кота, который является
        домашним котом, поэтому всё будет хорошо.

    ◦ Плохо: Метод подкласса:
        buyCat(): Animal . Клиентский
        код сломается, так как это непонятное животное (возмож-
        но, крокодил) не поместится в ящике-переноске для кота.


Метод не должен выбрасывать исключения, которые не свойственны базовому методу.
    Типы исключений в переопределённом методе должны совпадать или быть подтипами исключений, которые выбрасывает базовый метод.
    Блоки try-except в клиентском коде нацелены на конкретные типы исключений, выбрасываемые базовым методом.
    Поэтому неожиданное исключение, выброшенное подклассом, может проскочить сквозь обработчики клиентского кода и обрушить программу.


Метод не должен ужесточать пред-условия.
    Например, базовый метод работает с параметром типа int .
    Если подкласс требует, чтобы значение этого параметра к тому же было больше нуля, то это ужесточает предусловия.
    Клиентский код, который до этого отлично работал, подавая в метод негативные числа, теперь сломается при работе с объектом подкласса.


Метод не должен ослаблять пост-условия.
    Например, базовый метод требует, чтобы по завершению метода все подключения к базе данных были закрыты, а подкласс оставляет эти подключения открытыми, чтобы потом повторно использовать.
    Но клиентский код базового класса ничего об этом не знает.
    Он может завершить программу сразу после вызова метода, оставив запущенные процессы-призраки в системе.


Инварианты класса должны остаться без изменений.
    Инвариант — это набор условий, при которых объект имеет смысл.
    Например, инвариант кота — это наличие четырёх лап, хвоста, способность мурчать и прочее.
    Инвариант может быть описан не только явным контрактом или проверками в методах класса, но и косвенно, например, юнит-тестами или клиентским кодом.


Подкласс не должен изменять значения приватных полей базового класса.
    Этот пункт звучит странно, но в некоторых языках доступ к приватным полям можно получить через механизм рефлексии.
    В Python и вовсе нет жёсткой защиты приватных полей.


